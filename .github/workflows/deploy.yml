name: Blue/Green Deployment to AWS ECS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: strapi-app-vivek
  ECR_REGISTRY: 607700977843.dkr.ecr.us-east-2.amazonaws.com
  ECS_CLUSTER: strapi-cluster-vivek
  ECS_SERVICE: strapi-service-vivek
  ECS_TASK_DEFINITION: strapi-task-vivek
  CODEDEPLOY_APPLICATION: strapi-app-vivek
  CODEDEPLOY_DEPLOYMENT_GROUP: strapi-deployment-group-vivek

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 2

    - name: Check for changes
      id: changes
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
          echo "changed=true" >> $GITHUB_OUTPUT
          echo "Force deployment requested"
        elif [ "${{ github.event_name }}" = "pull_request" ]; then
          echo "changed=false" >> $GITHUB_OUTPUT
          echo "PR event - skipping deployment"
        else
          # Always deploy on main branch pushes for now
          echo "changed=true" >> $GITHUB_OUTPUT
          echo "Main branch push - proceeding with deployment"
        fi

    - name: Configure AWS credentials
      if: steps.changes.outputs.changed == 'true'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      if: steps.changes.outputs.changed == 'true'
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Create short SHA
      if: steps.changes.outputs.changed == 'true'
      id: short-sha
      run: |
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-8)
        echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
        echo "Short SHA: $SHORT_SHA"

    - name: Build and push Docker image
      if: steps.changes.outputs.changed == 'true'
      id: build-image
      run: |
        # Build image with multiple tags
        IMAGE_TAG="${{ steps.short-sha.outputs.short_sha }}"
        IMAGE_URI="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"
        LATEST_URI="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest"
        
        echo "Building image: $IMAGE_URI"
        
        # Build the image
        docker build -t $IMAGE_URI -t $LATEST_URI .
        
        # Push both tags
        echo "Pushing image: $IMAGE_URI"
        docker push $IMAGE_URI
        
        echo "Pushing latest: $LATEST_URI"
        docker push $LATEST_URI
        
        # Set output for later steps
        echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT
        echo "âœ… Image built and pushed successfully: $IMAGE_URI"

    - name: Download current task definition
      if: steps.changes.outputs.changed == 'true'
      id: download-task-def
      run: |
        aws ecs describe-task-definition \
          --task-definition ${{ env.ECS_TASK_DEFINITION }} \
          --query taskDefinition > task-definition.json
        
        echo "Current task definition downloaded"
        echo "Current task definition:"
        cat task-definition.json | jq '.containerDefinitions[0].image'

    - name: Update task definition with new image
      if: steps.changes.outputs.changed == 'true'
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition.json
        container-name: strapi
        image: ${{ steps.build-image.outputs.image_uri }}

    - name: Register new task definition
      if: steps.changes.outputs.changed == 'true'
      id: register-task-def
      run: |
        echo "Registering new task definition with image: ${{ steps.build-image.outputs.image_uri }}"
        
        NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://${{ steps.task-def.outputs.task-definition }} \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "new_task_def_arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT
        echo "New task definition registered: $NEW_TASK_DEF_ARN"

    - name: Verify image exists in ECR
      if: steps.changes.outputs.changed == 'true'
      run: |
        echo "Verifying image exists in ECR..."
        IMAGE_TAG="${{ steps.short-sha.outputs.short_sha }}"
        
        # Check if image exists
        if aws ecr describe-images \
          --repository-name ${{ env.ECR_REPOSITORY }} \
          --image-ids imageTag=$IMAGE_TAG \
          --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          echo "âœ… Image verified in ECR: ${{ steps.build-image.outputs.image_uri }}"
        else
          echo "âŒ Image not found in ECR!"
          echo "Available images:"
          aws ecr describe-images --repository-name ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} || echo "No images found or repository doesn't exist"
          exit 1
        fi

    - name: Create AppSpec for CodeDeploy
      if: steps.changes.outputs.changed == 'true'
      id: create-appspec
      run: |
        cat > appspec.json << EOF
        {
          "version": 0.0,
          "Resources": [
            {
              "TargetService": {
                "Type": "AWS::ECS::Service",
                "Properties": {
                  "TaskDefinition": "${{ steps.register-task-def.outputs.new_task_def_arn }}",
                  "LoadBalancerInfo": {
                    "ContainerName": "strapi",
                    "ContainerPort": 1337
                  }
                }
              }
            }
          ]
        }
        EOF
        
        echo "AppSpec created:"
        cat appspec.json

    - name: Start CodeDeploy deployment
      if: steps.changes.outputs.changed == 'true'
      id: deploy
      run: |
        # Create deployment input
        cat > deployment-input.json << EOF
        {
          "applicationName": "${{ env.CODEDEPLOY_APPLICATION }}",
          "deploymentGroupName": "${{ env.CODEDEPLOY_DEPLOYMENT_GROUP }}",
          "deploymentConfigName": "CodeDeployDefault.ECSCanary10Percent5Minutes",
          "revision": {
            "revisionType": "AppSpecContent",
            "appSpecContent": {
              "content": $(cat appspec.json | jq -R -s .)
            }
          },
          "description": "Deployment from GitHub Actions - Image: ${{ steps.build-image.outputs.image_uri }}"
        }
        EOF
        
        echo "Deployment input:"
        cat deployment-input.json
        
        # Start deployment
        DEPLOYMENT_ID=$(aws deploy create-deployment \
          --cli-input-json file://deployment-input.json \
          --query 'deploymentId' \
          --output text)
        
        echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
        echo "Deployment started with ID: $DEPLOYMENT_ID"

    # ... rest of the monitoring steps remain the same ...

    - name: Monitor deployment
      if: steps.changes.outputs.changed == 'true'
      id: monitor
      run: |
        DEPLOYMENT_ID="${{ steps.deploy.outputs.deployment_id }}"
        echo "Monitoring deployment: $DEPLOYMENT_ID"
        
        # Function to get deployment status
        get_deployment_status() {
          aws deploy get-deployment \
            --deployment-id "$1" \
            --query 'deploymentInfo.status' \
            --output text 2>/dev/null || echo "UNKNOWN"
        }
        
        # Monitor loop
        TIMEOUT=1800  # 30 minutes
        ELAPSED=0
        INTERVAL=30
        
        while [ $ELAPSED -lt $TIMEOUT ]; do
          STATUS=$(get_deployment_status "$DEPLOYMENT_ID")
          echo "Deployment status: $STATUS (${ELAPSED}s elapsed)"
          
          case $STATUS in
            "Succeeded")
              echo "âœ… Deployment completed successfully!"
              echo "deployment_status=success" >> $GITHUB_OUTPUT
              break
              ;;
            "Failed"|"Stopped")
              echo "âŒ Deployment failed with status: $STATUS"
              
              # Get failure details
              echo "Failure details:"
              aws deploy get-deployment \
                --deployment-id "$DEPLOYMENT_ID" \
                --query 'deploymentInfo.errorInformation' \
                --output text || echo "No error details available"
              
              echo "deployment_status=failed" >> $GITHUB_OUTPUT
              exit 1
              ;;
            "Created"|"Queued"|"InProgress")
              echo "â³ Deployment in progress..."
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
              ;;
            "UNKNOWN")
              echo "âš ï¸ Unable to get deployment status, retrying..."
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
              ;;
            *)
              echo "âš ï¸ Unknown status: $STATUS"
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
              ;;
          esac
        done
        
        if [ $ELAPSED -ge $TIMEOUT ]; then
          echo "âŒ Deployment monitoring timed out after $TIMEOUT seconds"
          echo "deployment_status=timeout" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: Get deployment URLs
      if: steps.changes.outputs.changed == 'true' && steps.monitor.outputs.deployment_status == 'success'
      id: urls
      run: |
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names "strapi-alb-vivek" \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        echo "main_url=http://$ALB_DNS" >> $GITHUB_OUTPUT
        echo "test_url=http://$ALB_DNS:8080" >> $GITHUB_OUTPUT
        
        echo "ðŸŒ Main URL: http://$ALB_DNS"
        echo "ðŸ§ª Test URL: http://$ALB_DNS:8080"

    - name: Deployment summary
      if: always() && steps.changes.outputs.changed == 'true'
      run: |
        echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Short SHA:** ${{ steps.short-sha.outputs.short_sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Image:** ${{ steps.build-image.outputs.image_uri }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Task Definition:** ${{ steps.register-task-def.outputs.new_task_def_arn }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Deployment ID:** ${{ steps.deploy.outputs.deployment_id }}" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ steps.monitor.outputs.deployment_status }}" = "success" ]; then
          echo "- **Status:** âœ… Success" >> $GITHUB_STEP_SUMMARY
          echo "- **Main URL:** ${{ steps.urls.outputs.main_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Test URL:** ${{ steps.urls.outputs.test_url }}" >> $GITHUB_STEP_SUMMARY
        else
          echo "- **Status:** âŒ Failed" >> $GITHUB_STEP_SUMMARY
        fi

    - name: Skip deployment message
      if: steps.changes.outputs.changed == 'false'
      run: |
        echo "## Deployment Skipped" >> $GITHUB_STEP_SUMMARY
        echo "No significant changes detected or this is a PR event." >> $GITHUB_STEP_SUMMARY
        echo "Deployment was skipped." >> $GITHUB_STEP_SUMMARY