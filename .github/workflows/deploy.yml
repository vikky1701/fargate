name: Blue/Green Deployment to AWS ECS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: strapi-app-vivek
  ECR_REGISTRY: 607700977843.dkr.ecr.us-east-2.amazonaws.com
  ECS_CLUSTER: strapi-cluster-vivek
  ECS_SERVICE: strapi-service-vivek
  ECS_TASK_DEFINITION: strapi-task-vivek
  CODEDEPLOY_APPLICATION: strapi-app-vivek
  CODEDEPLOY_DEPLOYMENT_GROUP: strapi-deployment-group-vivek

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 2

    - name: Check for changes
      id: changes
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
          echo "changed=true" >> $GITHUB_OUTPUT
          echo "Force deployment requested"
        elif [ "${{ github.event_name }}" = "pull_request" ]; then
          echo "changed=false" >> $GITHUB_OUTPUT
          echo "PR event - skipping deployment"
        else
          # Always deploy on main branch pushes for now
          echo "changed=true" >> $GITHUB_OUTPUT
          echo "Main branch push - proceeding with deployment"
        fi

    - name: Configure AWS credentials
      if: steps.changes.outputs.changed == 'true'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      if: steps.changes.outputs.changed == 'true'
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Create short SHA
      if: steps.changes.outputs.changed == 'true'
      id: short-sha
      run: |
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-8)
        echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
        echo "Short SHA: $SHORT_SHA"

    - name: Build and push Docker image
      if: steps.changes.outputs.changed == 'true'
      id: build-image
      run: |
        # Define image tags
        IMAGE_TAG="${{ steps.short-sha.outputs.short_sha }}"
        IMAGE_URI="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"
        LATEST_URI="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest"
        
        echo "Building image with SHA tag: $IMAGE_TAG"
        echo "Image URI: $IMAGE_URI"
        
        # Build the image with both tags
        docker build -t $IMAGE_URI -t $LATEST_URI .
        
        # Verify the image was built
        echo "Verifying built image..."
        docker images | grep ${{ env.ECR_REPOSITORY }}
        
        # Push SHA-tagged image first (this is what we'll deploy)
        echo "Pushing SHA-tagged image: $IMAGE_URI"
        docker push $IMAGE_URI
        
        # Push latest tag
        echo "Pushing latest image: $LATEST_URI"
        docker push $LATEST_URI
        
        # Set output for later steps - ALWAYS use the SHA-tagged image for deployment
        echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT
        echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "âœ… Image built and pushed successfully: $IMAGE_URI"

    - name: Verify image exists in ECR
      if: steps.changes.outputs.changed == 'true'
      run: |
        echo "Verifying SHA-tagged image exists in ECR..."
        IMAGE_TAG="${{ steps.build-image.outputs.image_tag }}"
        
        # Wait a moment for ECR to register the image
        sleep 10
        
        # Check if the specific SHA-tagged image exists
        if aws ecr describe-images \
          --repository-name ${{ env.ECR_REPOSITORY }} \
          --image-ids imageTag=$IMAGE_TAG \
          --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          echo "âœ… SHA-tagged image verified in ECR: ${{ steps.build-image.outputs.image_uri }}"
          
          # Get image details
          aws ecr describe-images \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-ids imageTag=$IMAGE_TAG \
            --region ${{ env.AWS_REGION }} \
            --query 'imageDetails[0].{Digest:imageDigest,Size:imageSizeInBytes,PushedAt:imagePushedAt}'
        else
          echo "âŒ SHA-tagged image not found in ECR!"
          echo "Available images:"
          aws ecr describe-images \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --region ${{ env.AWS_REGION }} \
            --query 'imageDetails[*].{Tags:imageTags,Digest:imageDigest,PushedAt:imagePushedAt}' || echo "No images found"
          exit 1
        fi

    - name: Download current task definition
      if: steps.changes.outputs.changed == 'true'
      id: download-task-def
      run: |
        echo "Downloading current task definition..."
        aws ecs describe-task-definition \
          --task-definition ${{ env.ECS_TASK_DEFINITION }} \
          --query taskDefinition > task-definition.json
        
        echo "Current task definition downloaded"
        echo "Current image in task definition:"
        cat task-definition.json | jq -r '.containerDefinitions[0].image'

    - name: Update task definition with new image
      if: steps.changes.outputs.changed == 'true'
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition.json
        container-name: strapi
        image: ${{ steps.build-image.outputs.image_uri }}

    - name: Register new task definition
      if: steps.changes.outputs.changed == 'true'
      id: register-task-def
      run: |
        echo "Registering new task definition with image: ${{ steps.build-image.outputs.image_uri }}"
        
        # Validate the task definition file
        echo "Validating task definition..."
        cat ${{ steps.task-def.outputs.task-definition }} | jq -r '.containerDefinitions[0].image'
        
        NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://${{ steps.task-def.outputs.task-definition }} \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "new_task_def_arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT
        echo "New task definition registered: $NEW_TASK_DEF_ARN"
        
        # Verify the new task definition has the correct image
        echo "Verifying new task definition image..."
        aws ecs describe-task-definition \
          --task-definition "$NEW_TASK_DEF_ARN" \
          --query 'taskDefinition.containerDefinitions[0].image' \
          --output text

    - name: Create AppSpec for CodeDeploy
      if: steps.changes.outputs.changed == 'true'
      id: create-appspec
      run: |
        cat > appspec.json << EOF
        {
          "version": 0.0,
          "Resources": [
            {
              "TargetService": {
                "Type": "AWS::ECS::Service",
                "Properties": {
                  "TaskDefinition": "${{ steps.register-task-def.outputs.new_task_def_arn }}",
                  "LoadBalancerInfo": {
                    "ContainerName": "strapi",
                    "ContainerPort": 1337
                  }
                }
              }
            }
          ]
        }
        EOF
        
        echo "AppSpec created for task definition: ${{ steps.register-task-def.outputs.new_task_def_arn }}"
        echo "AppSpec content:"
        cat appspec.json | jq .

    - name: Start CodeDeploy deployment
      if: steps.changes.outputs.changed == 'true'
      id: deploy
      run: |
        # Create deployment input
        cat > deployment-input.json << EOF
        {
          "applicationName": "${{ env.CODEDEPLOY_APPLICATION }}",
          "deploymentGroupName": "${{ env.CODEDEPLOY_DEPLOYMENT_GROUP }}",
          "deploymentConfigName": "CodeDeployDefault.ECSCanary10Percent5Minutes",
          "revision": {
            "revisionType": "AppSpecContent",
            "appSpecContent": {
              "content": $(cat appspec.json | jq -R -s .)
            }
          },
          "description": "GitHub Actions deployment - SHA: ${{ steps.short-sha.outputs.short_sha }} - Image: ${{ steps.build-image.outputs.image_uri }}"
        }
        EOF
        
        echo "Starting CodeDeploy deployment..."
        echo "Deployment configuration:"
        cat deployment-input.json | jq .
        
        # Start deployment
        DEPLOYMENT_ID=$(aws deploy create-deployment \
          --cli-input-json file://deployment-input.json \
          --query 'deploymentId' \
          --output text)
        
        echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
        echo "âœ… Deployment started with ID: $DEPLOYMENT_ID"
        echo "ðŸ” Deploying image: ${{ steps.build-image.outputs.image_uri }}"

    - name: Monitor deployment
      if: steps.changes.outputs.changed == 'true'
      id: monitor
      run: |
        DEPLOYMENT_ID="${{ steps.deploy.outputs.deployment_id }}"
        echo "Monitoring deployment: $DEPLOYMENT_ID"
        
        # Function to get deployment status
        get_deployment_status() {
          aws deploy get-deployment \
            --deployment-id "$1" \
            --query 'deploymentInfo.status' \
            --output text 2>/dev/null || echo "UNKNOWN"
        }
        
        # Monitor loop with increased timeout for build time
        TIMEOUT=2700  # 45 minutes to account for build + deployment time
        ELAPSED=0
        INTERVAL=30
        
        while [ $ELAPSED -lt $TIMEOUT ]; do
          STATUS=$(get_deployment_status "$DEPLOYMENT_ID")
          echo "Deployment status: $STATUS (${ELAPSED}s elapsed)"
          
          case $STATUS in
            "Succeeded")
              echo "âœ… Deployment completed successfully!"
              echo "ðŸŽ¯ Successfully deployed image: ${{ steps.build-image.outputs.image_uri }}"
              echo "deployment_status=success" >> $GITHUB_OUTPUT
              break
              ;;
            "Failed"|"Stopped")
              echo "âŒ Deployment failed with status: $STATUS"
              
              # Get detailed failure information
              echo "Failure details:"
              aws deploy get-deployment \
                --deployment-id "$DEPLOYMENT_ID" \
                --query 'deploymentInfo.errorInformation' \
                --output table || echo "No error details available"
              
              # Get deployment events for more context
              echo "Recent deployment events:"
              aws deploy list-deployment-instances \
                --deployment-id "$DEPLOYMENT_ID" \
                --query 'instancesList[*]' \
                --output table || echo "No deployment instances found"
              
              echo "deployment_status=failed" >> $GITHUB_OUTPUT
              exit 1
              ;;
            "Created"|"Queued"|"InProgress")
              echo "â³ Deployment in progress..."
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
              ;;
            "UNKNOWN")
              echo "âš ï¸ Unable to get deployment status, retrying..."
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
              ;;
            *)
              echo "âš ï¸ Unknown status: $STATUS"
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
              ;;
          esac
        done
        
        if [ $ELAPSED -ge $TIMEOUT ]; then
          echo "âŒ Deployment monitoring timed out after $TIMEOUT seconds"
          echo "deployment_status=timeout" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: Get deployment URLs
      if: steps.changes.outputs.changed == 'true' && steps.monitor.outputs.deployment_status == 'success'
      id: urls
      run: |
        echo "Getting load balancer DNS..."
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names "strapi-alb-vivek" \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        echo "main_url=http://$ALB_DNS" >> $GITHUB_OUTPUT
        echo "test_url=http://$ALB_DNS:8080" >> $GITHUB_OUTPUT
        
        echo "ðŸŒ Main URL: http://$ALB_DNS"
        echo "ðŸ§ª Test URL: http://$ALB_DNS:8080"

    - name: Deployment summary
      if: always() && steps.changes.outputs.changed == 'true'
      run: |
        echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| **Commit SHA** | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **Short SHA** | \`${{ steps.short-sha.outputs.short_sha }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **Branch** | \`${{ github.ref_name }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **Image** | \`${{ steps.build-image.outputs.image_uri }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **Task Definition** | \`${{ steps.register-task-def.outputs.new_task_def_arn }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **Deployment ID** | \`${{ steps.deploy.outputs.deployment_id }}\` |" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ steps.monitor.outputs.deployment_status }}" = "success" ]; then
          echo "| **Status** | âœ… **SUCCESS** |" >> $GITHUB_STEP_SUMMARY
          echo "| **Main URL** | [${{ steps.urls.outputs.main_url }}](${{ steps.urls.outputs.main_url }}) |" >> $GITHUB_STEP_SUMMARY
          echo "| **Test URL** | [${{ steps.urls.outputs.test_url }}](${{ steps.urls.outputs.test_url }}) |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| **Status** | âŒ **FAILED** |" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸŽ¯ Deployed Image Details" >> $GITHUB_STEP_SUMMARY
        echo "The deployment used the image tagged with commit SHA \`${{ steps.short-sha.outputs.short_sha }}\` to ensure exact version tracking." >> $GITHUB_STEP_SUMMARY

    - name: Skip deployment message
      if: steps.changes.outputs.changed == 'false'
      run: |
        echo "## â­ï¸ Deployment Skipped" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "No significant changes detected or this is a PR event." >> $GITHUB_STEP_SUMMARY
        echo "Deployment was skipped to avoid unnecessary deployments." >> $GITHUB_STEP_SUMMARY